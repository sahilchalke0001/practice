# 14. Longest Common Prefix

# Input: strs = ["bat","bag","bank","band"]

# Output: "ba"

Sure! Let's go through the following code step by step, explaining what each line does, and adding a detailed explanation for each **step** involved in finding the **Longest Common Prefix (LCP)**:

---

### ✅ Code:

```python
res = ""

for i in range(len(strs[0])):
    for s in strs:
        if i == len(s) or s[i] != strs[0][i]:
            return res
    res += strs[0][i]

return res
```

---

### ✅ Goal:

To find the **longest common prefix** shared among all strings in the list `strs`.

---

### ✅ Step-by-Step Breakdown:

#### 🔸 Step 1: Initialize result

```python
res = ""
```

* We start with an empty result string `res`, which will store the common prefix as we find it.

---

#### 🔸 Step 2: Loop through characters of the first string

```python
for i in range(len(strs[0])):
```

* We loop through **each character position `i`** of the **first string**.
* The idea is to **compare the character at position `i` in all strings**.

---

#### 🔸 Step 3: For each position `i`, compare with other strings

```python
for s in strs:
```

* For each index `i`, we loop over **each string `s` in the list**.
* We're checking if **every string has the same character at position `i`** as the first string.

---

#### 🔸 Step 4: Check two conditions

```python
if i == len(s) or s[i] != strs[0][i]:
    return res
```

* `i == len(s)` → means the current string is **shorter** than index `i`. So, no common character at that index.
* `s[i] != strs[0][i]` → means there's a **mismatch** at index `i`.

👉 If **any string** does **not** match the character at this position, we immediately return `res` (the common prefix found so far).

---

#### 🔸 Step 5: If all match, add character to result

```python
res += strs[0][i]
```

* If the character at position `i` matched across **all strings**, we **append** that character to `res`.

---

#### 🔸 Step 6: Finish loop and return result

```python
return res
```

* Once we've checked all characters in the first string **without mismatches**, `res` will contain the full LCP.
* If a mismatch was found early, the loop will return before finishing.

---

### 🧠 Example Dry Run:

#### Input:

```python
strs = ["flower", "flow", "flight"]
```

#### Iteration 1: `i = 0` (Check 'f')

* All strings have 'f' at index 0 → OK ✅ → `res = "f"`

#### Iteration 2: `i = 1` (Check 'l')

* All strings have 'l' at index 1 → OK ✅ → `res = "fl"`

#### Iteration 3: `i = 2` (Check 'o' vs 'i')

* `"flower"` has 'o', `"flow"` has 'o', but `"flight"` has 'i' ❌
* Mismatch → Return `"fl"`

---

### ✅ Final Output:

```python
"fl"
```

---

### Summary of Steps:

1. Initialize `res` as empty.
2. Loop through character positions of the first string.
3. For each character position `i`, check if all strings have the same character at that index.
4. If any string ends early or has a mismatch, return current `res`.
5. If all match, add character to `res`.
6. Return final result.

---
### ✅ Time and Space Complexity of the Code

### ⏱ **Time Complexity: `O(N * M)`**

Where:

* `N` = Number of strings in the list `strs`
* `M` = Length of the shortest string (worst case: all characters checked)

#### 🔹 Explanation:

* The outer loop runs up to `M` times (i.e. `len(strs[0])`, but in worst case limited by shortest string).
* The inner loop runs `N` times for each character index.
* So in the worst case (all strings share a long prefix), it does `N * M` comparisons.

✅ **Worst-case:** All strings are identical → full nested loop runs.
✅ **Best-case:** Mismatch on the 1st character → exits early with O(1).

---

### 📦 **Space Complexity: `O(1)` (excluding output)**

* No extra space used other than:

  * Variable `res` which holds the result (common prefix).
* Since `res` is built character by character (up to `M` characters), it does **not** use additional data structures.

✅ If you're counting output space (i.e., result string), then space is **O(M)** for storing the prefix.

---

### ✅ Final Complexity:

| Case          | Time Complexity | Space Complexity |
| ------------- | --------------- | ---------------- |
| Best Case     | O(1)            | O(1)             |
| Average/Worst | O(N × M)        | O(M) (output)    |

Let me know if you'd like this analyzed for a different approach (like Trie-based or sorting-based).
